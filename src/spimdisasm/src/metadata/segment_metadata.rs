/* SPDX-FileCopyrightText: Â© 2024-2025 Decompollaborate */
/* SPDX-License-Identifier: MIT */

use alloc::collections::btree_map::{self, BTreeMap};
use alloc::vec::Vec;

use crate::addresses::{AddressRange, Rom, RomVramRange, Size, Vram};
use crate::collections::addended_ordered_map::{AddendedOrderedMap, FindSettings};
use crate::section_type::SectionType;

use super::{symbol_metadata::GeneratedBy, OverlayCategoryName};
use super::{SymbolMetadata, SymbolType};

#[derive(Debug, Clone, Hash, PartialEq, PartialOrd)]
pub struct SegmentMetadata {
    ranges: RomVramRange,

    category_name: Option<OverlayCategoryName>,

    symbols: AddendedOrderedMap<Vram, SymbolMetadata>,
    // constants: BTreeMap<Vram, SymbolMetadata>,

    //
    /// Stuff that looks like pointers. Found referenced by data.
    new_pointer_in_data: BTreeMap<Vram, Vec<Rom>>,
    //
    // is_the_unknown_segment: bool,
}

impl SegmentMetadata {
    pub(crate) const fn new(
        ranges: RomVramRange,
        category_name: Option<OverlayCategoryName>,
    ) -> Self {
        Self {
            ranges,
            category_name,

            symbols: AddendedOrderedMap::new(),
            new_pointer_in_data: BTreeMap::new(),
        }
    }

    pub const fn rom_vram_range(&self) -> &RomVramRange {
        &self.ranges
    }

    pub const fn rom_range(&self) -> &AddressRange<Rom> {
        self.ranges.rom()
    }
    /*
    pub(crate) fn rom_range_mut(&mut self) -> &mut AddressRange<Rom> {
        &mut self.rom_range
    }
    */
    pub fn in_rom_range(&self, rom: Rom) -> bool {
        self.ranges.rom().in_range(rom)
    }

    pub const fn vram_range(&self) -> &AddressRange<Vram> {
        self.ranges.vram()
    }
    /*
    pub(crate) fn vram_range_mut(&mut self) -> &mut AddressRange<Vram> {
        &mut self.vram_range
    }
    */
    pub fn in_vram_range(&self, vram: Vram) -> bool {
        self.ranges.vram().in_range(vram)
    }

    pub const fn rom_size(&self) -> Size {
        self.ranges.rom().size()
    }

    pub fn vram_size(&self) -> Size {
        self.ranges.vram().size()
    }

    /*
    pub fn vram_from_rom(&self, rom: Rom) -> Option<Vram> {
        if let Some(rom_range) = self.rom_range {
            let offset = VramOffset::new((rom.inner() as i32) - (rom_range.start().inner() as i32));

            Some(self.vram_range.start() + offset)
        } else {
            None
        }
    }
    */

    pub const fn category_name(&self) -> Option<&OverlayCategoryName> {
        self.category_name.as_ref()
    }

    pub const fn symbols(&self) -> &AddendedOrderedMap<Vram, SymbolMetadata> {
        &self.symbols
    }
}

impl SegmentMetadata {
    pub(crate) fn add_symbol(
        &mut self,
        vram: Vram,
        rom: Option<Rom>,
        generated_by: GeneratedBy,
        section_type: Option<SectionType>,
        allow_sym_with_addend: bool, // false
    ) -> &mut SymbolMetadata {
        let sym = self.symbols.find_mut_or_insert_with(
            &vram,
            FindSettings::new().with_allow_addend(allow_sym_with_addend),
            || SymbolMetadata::new(generated_by, vram),
        );
        if let Some(rom) = rom {
            *sym.rom_mut() = Some(rom);
        }
        if let Some(section_type) = section_type {
            *sym.section_type_mut() = Some(section_type);
        }
        sym
    }

    pub(crate) fn add_function(
        &mut self,
        vram: Vram,
        rom: Option<Rom>,
        generated_by: GeneratedBy,
    ) -> &mut SymbolMetadata {
        let sym = self.add_symbol(vram, rom, generated_by, Some(SectionType::Text), false);
        sym.set_type(SymbolType::Function, generated_by);
        sym
    }

    pub(crate) fn add_branch_label(
        &mut self,
        vram: Vram,
        rom: Option<Rom>,
        generated_by: GeneratedBy,
    ) -> &mut SymbolMetadata {
        let sym = self.add_symbol(vram, rom, generated_by, Some(SectionType::Text), false);
        match sym.sym_type() {
            Some(SymbolType::Function)
            | Some(SymbolType::JumptableLabel)
            | Some(SymbolType::GccExceptTableLabel) => {
                // Functions, jumptable labels and gccexcepttable labels take precedence over plain labels.

                if generated_by == GeneratedBy::Autogenerated {
                    // This type may come from the user, so if we haven't set what type we detected this type to be then set it anyways.
                    // Setting it doesn't really matter since user-declread info takes precendence anyways
                    match sym.autodetected_type() {
                        Some(SymbolType::Function)
                        | Some(SymbolType::JumptableLabel)
                        | Some(SymbolType::GccExceptTableLabel) => {}
                        _ => sym.set_type(SymbolType::BranchLabel, generated_by),
                    }
                }
            }
            _ => sym.set_type(SymbolType::BranchLabel, generated_by),
        }
        sym
    }

    pub(crate) fn add_jumptable(
        &mut self,
        vram: Vram,
        rom: Option<Rom>,
        generated_by: GeneratedBy,
    ) -> &mut SymbolMetadata {
        let sym = self.add_symbol(vram, rom, generated_by, Some(SectionType::Rodata), false);
        sym.set_type(SymbolType::Jumptable, generated_by);
        sym
    }

    pub(crate) fn add_jumptable_label(
        &mut self,
        vram: Vram,
        rom: Option<Rom>,
        generated_by: GeneratedBy,
    ) -> &mut SymbolMetadata {
        let sym = self.add_symbol(vram, rom, generated_by, Some(SectionType::Text), false);
        match sym.sym_type() {
            Some(SymbolType::Function) | Some(SymbolType::GccExceptTableLabel) => {
                // Functions and gccexcepttable labels take precedence over jumptable labels.

                if generated_by == GeneratedBy::Autogenerated {
                    // This type may come from the user, so if we haven't set what type we detected this type to be then set it anyways.
                    // Setting it doesn't really matter since user-declread info takes precendence anyways
                    match sym.autodetected_type() {
                        Some(SymbolType::Function) | Some(SymbolType::GccExceptTableLabel) => {}
                        _ => sym.set_type(SymbolType::JumptableLabel, generated_by),
                    }
                }
            }
            _ => sym.set_type(SymbolType::JumptableLabel, generated_by),
        }
        sym
    }

    pub(crate) fn add_gcc_except_table(
        &mut self,
        vram: Vram,
        rom: Option<Rom>,
        generated_by: GeneratedBy,
    ) -> &mut SymbolMetadata {
        let sym = self.add_symbol(
            vram,
            rom,
            generated_by,
            Some(SectionType::GccExceptTable),
            false,
        );
        sym.set_type(SymbolType::GccExceptTable, generated_by);
        sym
    }

    pub(crate) fn add_gcc_except_table_label(
        &mut self,
        vram: Vram,
        rom: Option<Rom>,
        generated_by: GeneratedBy,
    ) -> &mut SymbolMetadata {
        let sym = self.add_symbol(vram, rom, generated_by, Some(SectionType::Text), false);
        match sym.sym_type() {
            Some(SymbolType::Function) => {
                // Functions take precedence over gccexcepttable labels.

                if generated_by == GeneratedBy::Autogenerated {
                    // This type may come from the user, so if we haven't set what type we detected this type to be then set it anyways.
                    // Setting it doesn't really matter since user-declread info takes precendence anyways
                    match sym.autodetected_type() {
                        Some(SymbolType::Function) => {}
                        _ => sym.set_type(SymbolType::GccExceptTableLabel, generated_by),
                    }
                }
            }
            _ => sym.set_type(SymbolType::GccExceptTableLabel, generated_by),
        }
        sym
    }
}

impl SegmentMetadata {
    #[must_use]
    pub(crate) fn find_symbol(
        &self,
        vram: Vram,
        settings: FindSettings,
    ) -> Option<&SymbolMetadata> {
        self.symbols.find(&vram, settings)
    }

    /*
    #[must_use]
    pub(crate) fn find_symbol_mut(
        &mut self,
        vram: Vram,
        settings: FindSettings,
    ) -> Option<&mut SymbolMetadata> {
        self.symbols.find_mut(&vram, settings)
    }
    */

    pub(crate) fn find_symbols_range(
        &self,
        vram_range: AddressRange<Vram>,
    ) -> btree_map::Range<'_, Vram, SymbolMetadata> {
        self.symbols.range(vram_range)
    }
}

impl SegmentMetadata {
    pub(crate) fn add_possible_pointer_in_data(
        &mut self,
        possible_pointer: Vram,
        rom_address_referencing_pointer: Rom,
    ) {
        self.new_pointer_in_data
            .entry(possible_pointer)
            .or_default()
            .push(rom_address_referencing_pointer);
    }
    pub(crate) fn is_vram_a_possible_pointer_in_data(&self, vram: Vram) -> bool {
        self.new_pointer_in_data.contains_key(&vram)
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn check_symbol_bounds() {
        let rom_range = AddressRange::new(Rom::new(0), Rom::new(0x100));
        let vram_range = AddressRange::new(Vram::new(0), Vram::new(0x180));
        let ranges = RomVramRange::new(rom_range, vram_range);
        let mut segment = SegmentMetadata::new(ranges, None);

        *segment
            .add_symbol(
                Vram::new(0x100C),
                None,
                GeneratedBy::Autogenerated,
                None,
                true,
            )
            .user_declared_size_mut() = Some(Size::new(4));
        *segment
            .add_symbol(
                Vram::new(0x1000),
                None,
                GeneratedBy::Autogenerated,
                None,
                true,
            )
            .user_declared_size_mut() = Some(Size::new(4));
        *segment
            .add_symbol(
                Vram::new(0x1004),
                None,
                GeneratedBy::Autogenerated,
                None,
                true,
            )
            .user_declared_size_mut() = Some(Size::new(4));

        assert_eq!(
            segment
                .find_symbol(Vram::new(0x1000), FindSettings::new())
                .map(|sym| sym.vram()),
            Some(Vram::new(0x1000))
        );

        assert_eq!(
            segment
                .find_symbol(Vram::new(0x1002), FindSettings::new())
                .map(|sym| sym.vram()),
            Some(Vram::new(0x1000))
        );

        assert_eq!(
            segment
                .find_symbol(Vram::new(0x0F00), FindSettings::new())
                .map(|sym| sym.vram()),
            None
        );

        assert_eq!(
            segment
                .find_symbol(Vram::new(0x2000), FindSettings::new())
                .map(|sym| sym.vram()),
            None
        );

        assert_eq!(
            segment
                .find_symbol(
                    Vram::new(0x1002),
                    FindSettings::new().with_allow_addend(false)
                )
                .map(|sym| sym.vram()),
            None
        );

        assert_eq!(
            segment
                .find_symbol(
                    Vram::new(0x1100),
                    FindSettings::new().with_check_upper_limit(false)
                )
                .map(|sym| sym.vram()),
            Some(Vram::new(0x100C))
        );

        assert_eq!(
            segment
                .find_symbol(Vram::new(0x1008), FindSettings::new())
                .map(|sym| sym.vram()),
            None
        );

        assert_eq!(
            segment
                .find_symbol(
                    Vram::new(0x1008),
                    FindSettings::new().with_check_upper_limit(false)
                )
                .map(|sym| sym.vram()),
            Some(Vram::new(0x1004))
        );
    }
}
