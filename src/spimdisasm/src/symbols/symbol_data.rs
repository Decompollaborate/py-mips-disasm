/* SPDX-FileCopyrightText: Â© 2024 Decompollaborate */
/* SPDX-License-Identifier: MIT */

use alloc::vec::Vec;
use rabbitizer::Vram;

use crate::{
    address_range::AddressRange,
    context::{Context, OwnedSegmentNotFoundError},
    metadata::{GeneratedBy, SymbolType},
    parent_segment_info::ParentSegmentInfo,
    relocation::{RelocReferencedSym, RelocationInfo, RelocationType},
    rom_address::RomAddress,
    rom_vram_range::RomVramRange,
    section_type::SectionType,
    size::Size,
};

use super::{
    display::{SymDataDisplay, SymDataDisplaySettings},
    trait_symbol::RomSymbol,
    Symbol,
};

#[derive(Debug, Clone, Hash, PartialEq)]
pub struct SymbolData {
    ranges: RomVramRange,
    raw_bytes: Vec<u8>,
    parent_segment_info: ParentSegmentInfo,
    section_type: SectionType,
    relocs: Vec<Option<RelocationInfo>>,
}

impl SymbolData {
    pub(crate) fn new(
        context: &mut Context,
        raw_bytes: Vec<u8>,
        rom: RomAddress,
        vram: Vram,
        _in_section_offset: usize,
        parent_segment_info: ParentSegmentInfo,
        section_type: SectionType,
    ) -> Result<Self, OwnedSegmentNotFoundError> {
        let size = Size::new(raw_bytes.len() as u32);
        let rom_range = AddressRange::new(rom, rom + size);
        let vram_range = AddressRange::new(vram, vram + size);
        let ranges = RomVramRange::new(rom_range, vram_range);

        let mut relocs = vec![None; raw_bytes.len() / 4];

        let endian = context.global_config().endian();

        let owned_segment = context.find_owned_segment_mut(&parent_segment_info)?;
        let sym = owned_segment.add_symbol(
            vram,
            Some(rom),
            GeneratedBy::Autogenerated,
            Some(section_type),
            false,
        );
        *sym.autodetected_size_mut() = Some(size);
        sym.set_defined();

        let is_jtbl = sym.sym_type() == Some(&SymbolType::Jumptable);

        // TODO: improve heuristic to determine if should search for symbols
        if rom.inner() % 4 == 0 {
            for (i, word_bytes) in raw_bytes.chunks_exact(4).enumerate() {
                let word = endian.word_from_bytes(word_bytes);
                let word_vram = Vram::new(word);

                if owned_segment.in_vram_range(word_vram) {
                    if is_jtbl {
                        owned_segment.add_jumptable_label(
                            word_vram,
                            None,
                            GeneratedBy::Autogenerated,
                        );
                    } else {
                        owned_segment.add_symbol(
                            word_vram,
                            None,
                            GeneratedBy::Autogenerated,
                            None,
                            true,
                        );
                    }
                    relocs[i] = Some(
                        RelocationType::R_MIPS_32
                            .new_reloc_info(RelocReferencedSym::Address(word_vram)),
                    );
                } else {
                    // TODO
                }
            }
        }

        Ok(Self {
            ranges,
            raw_bytes,
            parent_segment_info,
            section_type,
            relocs,
        })
    }
}

impl SymbolData {
    pub fn raw_bytes(&self) -> &[u8] {
        &self.raw_bytes
    }
}

impl<'ctx, 'sym, 'flg> SymbolData {
    pub fn display(
        &'sym self,
        context: &'ctx Context,
        settings: &'flg SymDataDisplaySettings,
    ) -> SymDataDisplay<'ctx, 'sym, 'flg> {
        SymDataDisplay::new(context, self, settings)
    }
}

impl Symbol for SymbolData {
    fn vram_range(&self) -> &AddressRange<Vram> {
        self.ranges.vram()
    }

    fn parent_segment_info(&self) -> &ParentSegmentInfo {
        &self.parent_segment_info
    }

    #[must_use]
    fn section_type(&self) -> SectionType {
        self.section_type
    }
}

impl RomSymbol for SymbolData {
    #[must_use]
    fn rom_vram_range(&self) -> &RomVramRange {
        &self.ranges
    }

    fn relocs(&self) -> &[Option<RelocationInfo>] {
        &self.relocs
    }
}
