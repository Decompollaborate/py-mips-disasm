/* SPDX-FileCopyrightText: Â© 2024 Decompollaborate */
/* SPDX-License-Identifier: MIT */

use core::fmt;

use alloc::string::String;
use rabbitizer::Vram;

use crate::{
    config::GlobalConfig,
    metadata::{SegmentMetadata, SymbolMetadata, SymbolMetadataNameDisplay, SymbolType},
    rom_address::RomAddress,
};

pub(crate) enum WordComment {
    No,
    U32(u32),
    U64(u64),
}

#[derive(Debug, Clone, Hash, PartialEq, Eq, PartialOrd, Ord)]
pub struct SymCommonDisplaySettings {
    line_end: Option<String>,

    emit_asm_comment: bool,

    asm_indentation: u8,
}

impl SymCommonDisplaySettings {
    pub fn new() -> Self {
        Self {
            line_end: None,
            emit_asm_comment: true,
            asm_indentation: 4,
        }
    }

    pub fn line_end(&self) -> &str {
        if let Some(line_end) = &self.line_end {
            line_end
        } else {
            "\n"
        }
    }
}

impl SymCommonDisplaySettings {
    pub fn display_sym_property_comments(
        &self,
        f: &mut fmt::Formatter<'_>,
        sym: &SymbolMetadata,
        _owned_segment: &SegmentMetadata,
    ) -> fmt::Result {
        if !self.emit_asm_comment {
            return Ok(());
        }

        // if self.isStatic():
        if false {
            write!(f, "/* static variable */{}", self.line_end())?;
        }
        if let Some(_main_sym_vram) = sym.autogenerated_pad_info() {
            write!(
                f,
                "/* Automatically generated and unreferenced pad */{}",
                self.line_end()
            )?;
        }

        Ok(())
    }

    pub fn display_symbol_name(
        &self,
        f: &mut fmt::Formatter<'_>,
        global_config: &GlobalConfig,
        sym_name: &SymbolMetadataNameDisplay,
        sym: &SymbolMetadata,
        in_middle: bool,
    ) -> fmt::Result {
        // TODO: implement somewhere else:
        /*
        if not GlobalConfig.ASM_USE_SYMBOL_LABEL:
            return None
        label = ""
        if GlobalConfig.ASM_COMMENT:
            if self.isStatic():
                label += f"/* static variable */
{GlobalConfig.LINE_ENDS}"
            if self.isAutogeneratedPad():
                mainSymbolInfo = ""
                if self.autoCreatedPadMainSymbol is not None:
                    mainSymbolInfo = f" (generated by the size of {self.autoCreatedPadMainSymbol.getName()})"
        label += f" /* Automatically generated and unreferenced pad{mainSymbolInfo} */
{GlobalConfig.LINE_ENDS}"

        */

        if let Some(macro_labels) = global_config.macro_labels() {
            // Write the label, ie `glabel`, `dlabel`, etc
            if let Some(sym_type) = sym.sym_type() {
                match sym_type {
                    SymbolType::Function => {
                        if in_middle {
                            write!(f, "{}", macro_labels.alt_func())?;
                        } else {
                            write!(f, "{}", macro_labels.func())?;
                        }
                    }
                    SymbolType::JumptableLabel => write!(f, "{}", macro_labels.jtbl_label())?,
                    SymbolType::GccExceptTableLabel => write!(f, "{}", macro_labels.ehtbl_label())?,
                    SymbolType::BranchLabel
                    | SymbolType::Jumptable
                    | SymbolType::GccExceptTable
                    | SymbolType::Byte
                    | SymbolType::Short
                    | SymbolType::Word
                    | SymbolType::DWord
                    | SymbolType::Float32
                    | SymbolType::Float64
                    | SymbolType::CString
                    | SymbolType::UserCustom => write!(f, "{}", macro_labels.data())?,
                }
            } else {
                write!(f, "{}", macro_labels.data())?
            }

            write!(f, " {}", sym_name)?;

            match sym.visibility() {
                None | Some("global") | Some("globl") => {}
                Some(vis) => write!(f, ", {}", vis)?,
            }
        } else {
            /*
            .globl func_80045DD0
            .type func_80045DD0,@function
            .ent func_80045DD0
            func_80045DD0:
            */
            let vis = match sym.visibility() {
                None | Some("globl") => "globl",
                Some(vis) => vis,
            };
            write!(f, ".{} {}{}", vis, sym_name, self.line_end())?;

            if let Some(sym_type) = sym.sym_type() {
                match sym_type {
                    SymbolType::Function => {
                        write!(f, ".type {}, @function{}", sym_name, self.line_end())?;
                        if in_middle {
                            write!(f, ".aent {}{}", sym_name, self.line_end())?;
                        } else {
                            write!(f, ".ent {}{}", sym_name, self.line_end())?;
                        }
                    }
                    SymbolType::JumptableLabel
                    | SymbolType::GccExceptTableLabel
                    | SymbolType::BranchLabel => {}

                    SymbolType::Jumptable | SymbolType::GccExceptTable => {}
                    SymbolType::Byte
                    | SymbolType::Short
                    | SymbolType::Word
                    | SymbolType::DWord
                    | SymbolType::Float32
                    | SymbolType::Float64
                    | SymbolType::CString
                    | SymbolType::UserCustom => {
                        write!(f, ".type {}, @object{}", sym_name, self.line_end())?
                    }
                }
            } else {
                write!(f, ".type {}, @object{}", sym_name, self.line_end())?
            }

            write!(f, "{}:", sym_name)?;
        }

        /*
        if GlobalConfig.GLABEL_ASM_COUNT:
            if self.index is not None:
                label += f" # {self.index}"
        */

        write!(f, "{}", self.line_end())
    }

    /*
    pub fn display_symbol_start(&self, f: &mut fmt::Formatter<'_>, sym_name: &SymbolMetadataNameDisplay) -> fmt::Result {
        /*
        output = self.contextSym.getReferenceeSymbols()
        output += self.getPrevAlignDirective(0)

        symName = self.getName()
        output += self.getSymbolAsmDeclaration(symName, useGlobalLabel)
        */

        Ok(())
    }
    */

    pub fn display_sym_end(
        &self,
        f: &mut fmt::Formatter<'_>,
        global_config: &GlobalConfig,
        sym_name: &SymbolMetadataNameDisplay,
        sym: &SymbolMetadata,
    ) -> fmt::Result {
        if let Some(macro_labels) = global_config.macro_labels() {
            if let Some(sym_type) = sym.sym_type() {
                match sym_type {
                    SymbolType::Function => {
                        if let Some(func_end) = macro_labels.func_end() {
                            write!(f, "{} {}{}", func_end, sym_name, self.line_end())?;
                        }
                    }
                    SymbolType::JumptableLabel
                    | SymbolType::GccExceptTableLabel
                    | SymbolType::BranchLabel => {}

                    SymbolType::Jumptable
                    | SymbolType::GccExceptTable
                    | SymbolType::Byte
                    | SymbolType::Short
                    | SymbolType::Word
                    | SymbolType::DWord
                    | SymbolType::Float32
                    | SymbolType::Float64
                    | SymbolType::CString
                    | SymbolType::UserCustom => {
                        if let Some(data_end) = macro_labels.data_end() {
                            write!(f, "{} {}{}", data_end, sym_name, self.line_end())?;
                        }
                    }
                }
            } else {
                if let Some(data_end) = macro_labels.data_end() {
                    write!(f, "{} {}{}", data_end, sym_name, self.line_end())?;
                }
            }
        } else {
            match sym.sym_type() {
                Some(SymbolType::Function) => {
                    write!(f, ".end {}{}", sym_name, self.line_end())?;
                }
                _ => {}
            }
        }

        if global_config.emit_size_directive() {
            write!(f, ".size {}, . - {}{}", sym_name, sym_name, self.line_end())?;
        }

        Ok(())
    }

    pub fn display_asm_comment(
        &self,
        f: &mut fmt::Formatter<'_>,
        rom: Option<RomAddress>,
        vram: Vram,
        word_comment: WordComment,
    ) -> fmt::Result {
        if self.asm_indentation > 0 {
            write!(f, "{:width$}", " ", width = self.asm_indentation as usize)?;
        }

        if !self.emit_asm_comment {
            return Ok(());
        }

        // TODO:
        /*
        if emitRomOffset:
            offsetHex = "{0:0{1}X} ".format(localOffset + self.inFileOffset + self.commentOffset, common.GlobalConfig.ASM_COMMENT_OFFSET_WIDTH)
        else:
            offsetHex = ""

        currentVram = self.getVramOffset(localOffset)
        vramHex = f"{currentVram:08X}"

        wordValueHex = ""
        if wordValue is not None:
            if isDouble:
                wordValueHex = f"{common.Utils.qwordToCurrenEndian(wordValue):016X} "
            else:
                wordValueHex = f"{common.Utils.wordToCurrenEndian(wordValue):08X} "

        return f"{indentation}/* {offsetHex}{vramHex} {wordValueHex}*/
"
        */

        write!(f, "/* ")?;
        if let Some(rom) = rom {
            // TODO: implement display for RomAddress
            write!(f, "{:06X} ", rom.inner())?;
        }
        write!(f, "{} ", vram)?;

        // TODO: endian
        match word_comment {
            WordComment::No => {}
            WordComment::U32(word) => write!(f, "{:08X} ", word)?,
            WordComment::U64(dword) => write!(f, "{:016X} ", dword)?,
        }

        write!(f, "*/ ")
    }
}
