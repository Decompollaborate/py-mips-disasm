/* SPDX-FileCopyrightText: Â© 2024 Decompollaborate */
/* SPDX-License-Identifier: MIT */

use alloc::vec::Vec;
use rabbitizer::{Instruction, Vram};

use crate::{
    address_range::AddressRange,
    analysis::{InstructionAnalysisResult, InstructionAnalyzer},
    context::{Context, OwnedSegmentNotFoundError},
    metadata::GeneratedBy,
    parent_segment_info::ParentSegmentInfo,
    relocation::{RelocReferencedSym, RelocationInfo, RelocationType},
    rom_address::RomAddress,
    size::Size,
};

use super::{
    display::{FunctionDisplay, FunctionDisplaySettings},
    trait_symbol::RomSymbol,
    Symbol,
};

// TODO: move somewhere else
fn rom_from_vram(reference_rom: RomAddress, reference_vram: Vram, vram: Vram) -> RomAddress {
    assert!(vram >= reference_vram);
    let diff = vram - reference_vram;
    reference_rom + diff.try_into().unwrap()
}

#[derive(Debug, Clone, Hash, PartialEq)]
pub struct SymbolFunction {
    rom_range: AddressRange<RomAddress>,
    vram_range: AddressRange<Vram>,
    instructions: Vec<Instruction>,
    parent_segment_info: ParentSegmentInfo,

    instr_analysis: InstructionAnalysisResult,
    relocs: Vec<Option<RelocationInfo>>,
}

impl SymbolFunction {
    pub(crate) fn new(
        context: &mut Context,
        instructions: Vec<Instruction>,
        rom: RomAddress,
        vram: Vram,
        _in_section_offset: usize,
        parent_segment_info: ParentSegmentInfo,
    ) -> Result<Self, OwnedSegmentNotFoundError> {
        let size = Size::new(instructions.len() as u32 * 4);
        let rom_range = AddressRange::new(rom, rom + size);
        let vram_range = AddressRange::new(vram, vram + size);

        let mut relocs = vec![None; instructions.len()];

        let instr_analysis = InstructionAnalyzer::analyze(context, vram_range, &instructions);

        let owned_segment = context.find_owned_segment_mut(&parent_segment_info)?;
        let sym = owned_segment.add_function(vram, Some(rom), GeneratedBy::Autogenerated);
        *sym.autodetected_size_mut() = Some(size);
        sym.set_defined();

        for (instr_vram, target_vram) in instr_analysis.branch_targets() {
            /*
            if common.GlobalConfig.INPUT_FILE_TYPE == common.InputFileType.ELF:
                if self.getVromOffset(instrOffset) in self.context.globalRelocationOverrides:
                    # Avoid creating wrong symbols on elf files
                    continue
            */
            let branch_sym = owned_segment.add_branch_label(
                *target_vram,
                Some(rom_from_vram(rom, vram, *target_vram)),
                GeneratedBy::Autogenerated,
            );
            if let Some(typ) = branch_sym.sym_type() {
                if typ.valid_branch_target() {
                    let instr_index = (*instr_vram - vram).inner() / 4;
                    relocs[instr_index as usize] = Some(RelocationInfo::new(
                        RelocationType::R_MIPS_PC16,
                        RelocReferencedSym::Address(*target_vram),
                        0,
                    ));

                    // branch_sym.set_defined();
                    /*
                    labelSym.referenceCounter += 1
                    labelSym.referenceFunctions.add(self.contextSym)
                    labelSym.parentFunction = self.contextSym
                    labelSym.parentFileName = self.contextSym.parentFileName
                    self.contextSym.branchLabels.add(labelSym.vram, labelSym)
                    */
                }
            }
        }

        Ok(Self {
            rom_range,
            vram_range,
            instructions,
            parent_segment_info,
            instr_analysis,
            relocs,
        })
    }
}

impl SymbolFunction {
    pub fn rom_range(&self) -> AddressRange<RomAddress> {
        self.rom_range
    }

    // TODO: maybe remove?
    pub fn instructions(&self) -> &[Instruction] {
        &self.instructions
    }
}

impl<'ctx, 'sym, 'flg> SymbolFunction {
    pub fn display(
        &'sym self,
        context: &'ctx Context,
        settings: &'flg FunctionDisplaySettings,
    ) -> FunctionDisplay<'ctx, 'sym, 'flg> {
        FunctionDisplay::new(context, self, settings)
    }
}

impl Symbol for SymbolFunction {
    fn vram_range(&self) -> AddressRange<Vram> {
        self.vram_range
    }

    fn parent_segment_info(&self) -> &ParentSegmentInfo {
        &self.parent_segment_info
    }
}

impl RomSymbol for SymbolFunction {
    fn rom_range(&self) -> AddressRange<RomAddress> {
        self.rom_range
    }

    fn relocs(&self) -> &[Option<RelocationInfo>] {
        &self.relocs
    }
}
